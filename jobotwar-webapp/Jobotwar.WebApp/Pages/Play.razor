@page "/play"
@using Features.Api
@using Jobotwar.WebApp.Drawing
@using Jobotwar.WebApp.Services
@using Microsoft.Extensions.Logging
@using System.Threading
@using System.Collections.Immutable
@inject IApiClient _api
@inject TickerFactory _tickerFactory
@inject NavigationManager _navigationManager
@inject ILogger<Play> _log
@inject ILoggerFactory _loggerFactory;
@inject IModelContainer _model
@implements IDisposable

<h3>Play</h3>

@if (_playing == false)
{
    <ul class="nav nav-tabs">
        @foreach (var robot in _model.Robots)
        {
            var cssClass = robot == _selectedRobotModel ? "nav-link active" : "nav-link";
            <li class="nav-item">
                <a class="@cssClass" aria-current="page" @onclick="() => SelectRobot(robot)">@robot.Name</a>
            </li>
        }
        <li class="nav-item">
            <a class="nav-link bg-secondary text-white" aria-current="page" style="font-weight: normal; cursor: hand;" @onclick="AddRobot">+</a>
        </li>
        @* <button class="btn btn-info mx-3" @onclick="AddRobot">Add</button> *@
    </ul>

    <div class="border border-top-0">
        <RobotEditor @ref="_robotEditor" Robot="@_selectedRobotModel" />
    </div>
    <div class="my-3">
        <button class="btn btn-primary" @onclick="PlayGameAsync">&nbsp;Play!&nbsp;</button>
    @if (_model.Robots.Count > 1)
    {
        <button class="btn btn-light ml-1" @onclick="RemoveSelectedRobot">
            <span class="oi oi-circle-x"></span> Remove '@_selectedRobotModel?.Name'
        </button>
    }
    </div>
}
else
{
    <BECanvas Width="@BoardWidth" Height="@BoardHeight" @ref="_canvas"></BECanvas>
}

@code {
    private const int BoardWidth = 640;
    private const int BoardHeight = 480;
    private RobotEditor? _robotEditor;
    private RobotModel? _selectedRobotModel;
    private BECanvasComponent? _canvas;
    private CancellationTokenSource? _replayCancellationTokenSource;
    private bool _playing;

    private void SelectRobot(RobotModel? robotModel)
    {
        _log.LogInformation("selected robot: {SelectedRobot}", robotModel);
        if (robotModel != null && _model.Robots.Contains(robotModel) == false)
        {
            throw new ArgumentException($"{nameof(robotModel)} is not contained in the robot list");
        }
        _selectedRobotModel = robotModel;
    }

    private void RemoveSelectedRobot()
    {
        if (_selectedRobotModel == null)
        {
            return;
        }
        _model.RemoveRobot(_selectedRobotModel);
        SelectRobot(_model.Robots.FirstOrDefault());
    }

    private void AddRobot()
    {
        var robot = _model.NewRobot();
        SelectRobot(robot);
    }

    protected override Task OnInitializedAsync()
    {
        _navigationManager.LocationChanged += NavigationManager_LocationChanged;
        _selectedRobotModel = _model.Robots.FirstOrDefault();
        return base.OnInitializedAsync();
    }

    private void NavigationManager_LocationChanged(object? sender, LocationChangedEventArgs e)
    {
        _log.LogInformation("navigate to: '{QueryUri}', intercepted: {NavigationIntercepted}", e.Location, e.IsNavigationIntercepted);
    }

    private async Task PlayGameAsync()
    {
        var random = new Random();
        const int margin = 30;
        var (width, height) = (BoardWidth, BoardHeight);

        var setup = new InstantMatchSetup(5 * 60 * 1000, width, height,
            _model.Robots.Select(r => new InstantMatchRobot(r.Name, r.Code, "V2",
                    random.Next(margin, width - margin),
                    random.Next(margin, height - margin)))
                .ToArray());

        var result = await _api.PlayAsync(setup);
        var gameInfo = await _api.GetGameInfoAsync();

        _log.LogInformation("Result: {MatchResult}", result);
        var match = new MatchInfo(setup, result,
            _model.Robots.ToImmutableDictionary(
                r => r.Name,
                r => new RobotDrawingInfo(r.Color)));

        _replayCancellationTokenSource = new CancellationTokenSource();
        _playing = true;
        StateHasChanged();

        await MatchReplay.PlayAsync(match,
            gameInfo,
            await _canvas.CreateCanvas2DAsync(),
            _tickerFactory,
            _loggerFactory.CreateLogger<MatchReplay>(),
            _replayCancellationTokenSource.Token);

        _log.LogInformation("game replay finished");
        _playing = false;
        StateHasChanged();
    }

    public void Dispose()
    {
        _navigationManager.LocationChanged -= NavigationManager_LocationChanged;
        _log.LogInformation("page disposed: {Page}", this);
        _replayCancellationTokenSource?.Cancel();
    }
}
